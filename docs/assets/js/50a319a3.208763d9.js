"use strict";(self.webpackChunkuser_documentation=self.webpackChunkuser_documentation||[]).push([[3431],{6232:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>r,default:()=>d,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var o=n(5893),l=n(1151),a=n(4996);const i={sidebar_position:6},r="Parallel",s={id:"Core Development/Components/PARALLEL",title:"Parallel",description:"Parallel is a component block, which is a container to hold multiple, independent steps. Parallel blocks have a time frame (in seconds), which denotes the max time it will take the entire block to complete execution and is configurable. The steps inside the parallel flow are inserted by selecting a parallel container, then dragging the steps inside the block. The steps are not connected by links, meaning they are independent of each other and will run asynchronously.",source:"@site/docs/Core Development/Components/PARALLEL.md",sourceDirName:"Core Development/Components",slug:"/Core Development/Components/PARALLEL",permalink:"/Core Development/Components/PARALLEL",draft:!1,unlisted:!1,editUrl:"https://github.com/quickintegrate/docs/tree/main/Core Development/Components/PARALLEL.md",tags:[],version:"current",sidebarPosition:6,frontMatter:{sidebar_position:6},sidebar:"tutorialSidebar",previous:{title:"Sub-flow",permalink:"/Core Development/Components/SUBFLOW"},next:{title:"Private Flow",permalink:"/Core Development/Components/PRIVATE FLOW"}},p={},c=[];function h(e){const t={admonition:"admonition",code:"code",h1:"h1",li:"li",ol:"ol",p:"p",strong:"strong",...(0,l.a)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.h1,{id:"parallel",children:"Parallel"}),"\n",(0,o.jsx)(t.p,{children:"Parallel is a component block, which is a container to hold multiple, independent steps. Parallel blocks have a time frame (in seconds), which denotes the max time it will take the entire block to complete execution and is configurable. The steps inside the parallel flow are inserted by selecting a parallel container, then dragging the steps inside the block. The steps are not connected by links, meaning they are independent of each other and will run asynchronously."}),"\n",(0,o.jsx)(t.p,{children:"The below example shows the parallel component in a flow:"}),"\n",(0,o.jsx)("img",{src:(0,a.Z)("/img/Core Development/Components/parallel_flow.png")}),"\n",(0,o.jsx)(t.p,{children:"The trigger is rest, and the first step in the flow is a parallel block. The parallel block contains 2 steps, rest and db, which will execute parallely, within the timeframe defined in the parallel block. After the steps are executed, the output of each step is gathered and is then put inside the output of the parallel block."}),"\n",(0,o.jsxs)(t.p,{children:["So the output would be. ",(0,o.jsx)(t.strong,{children:"parallelOut[restOut, dbOut]"}),". The output can be:"]}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsx)(t.li,{children:"error of the step if any error"}),"\n",(0,o.jsx)(t.li,{children:"timeout error if the step was not completed within the timeframe of parallel"}),"\n",(0,o.jsx)(t.li,{children:"actual output of success."}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"If there is no output of the step, like the logger step, then the final output will not contain any output for that step."}),"\n",(0,o.jsxs)(t.p,{children:["The output of parallel is put in a map format, and will contain step name as key and the value as output of the step. So the value for the individual output can be extracted by, ",(0,o.jsx)(t.code,{children:'"$ParallelOut.rest"'})," and ",(0,o.jsx)(t.code,{children:'"$ParallelOut.db"'}),", for the above example. And the overall output can be taken like this, ",(0,o.jsx)(t.code,{children:'"$ParallelOut"'}),". Aside from getting the output from parallel flow like this, the user can also retrieve the output of individual steps by their output names too, if the step contains output."]}),"\n",(0,o.jsx)(t.p,{children:"There are 2 properties that can be set in a parallel block, one is the timeframe (in sec) and other is output name."}),"\n",(0,o.jsx)("img",{src:(0,a.Z)("/img/Core Development/Components/parallel_form.png")}),"\n",(0,o.jsx)(t.admonition,{type:"note",children:(0,o.jsx)(t.p,{children:"The parallel block is error proof, as even if the entire steps in the block fails or timeouts, then the parallel block itself does not fail. It will take whatever error is of the step itself as the output for the step. The way if there are 2 steps in a parallel block, and 1 step fails, it does not affect the other step, realizing the advantage of asynchronous."})})]})}function d(e={}){const{wrapper:t}={...(0,l.a)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(h,{...e})}):h(e)}},1151:(e,t,n)=>{n.d(t,{Z:()=>r,a:()=>i});var o=n(7294);const l={},a=o.createContext(l);function i(e){const t=o.useContext(a);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:i(e.components),o.createElement(a.Provider,{value:t},e.children)}}}]);